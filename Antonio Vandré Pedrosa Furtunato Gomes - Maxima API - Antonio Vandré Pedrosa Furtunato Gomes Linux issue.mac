/*
API Maxima de Antonio Vandré Pedrosa Furtunato Gomes (http://bit.ly/antoniovandre_legadoontologico) - Antonio Vandré Pedrosa Furtunato Gomes Android issue.

Pode ser necessária permissão para escrever em dispositivo.

Última atualização: 11-02-2019.
*/

/* Início funções e procedimentos programados por terceiros. */

/* Fim funções e procedimentos programados por terceiros. */

/* Início funções e procedimentos programados por Antonio Vandré Pedrosa Furtunato Gomes. */

/* Início setar variáveis globais. */

antoniovandre_armazenar_estatisticas_uso_funcoes : true$

antoniovandre_arquivo_estatisticas_funcoes : "/home/antoniovandre/antoniovandre_dropbox_sync_folder/antoniovandre_maxima_history.txt"$

antoniovandre_arquivo_grafico_estatisticas_funcoes : "/home/antoniovandre/antoniovandre_dropbox_sync_folder/antoniovandre_maxima_history.png"$ /* Requer outros softwares para processamento. */

antoniovandre_tempfile_1 : "/home/antoniovandre/avmt1"$

antoniovandre_tempfile_2 : "/home/antoniovandre/avmt2"$

antoniovandre_tempfile_3 : "/home/antoniovandre/avmt3"$

antoniovandre_testfile : "/home/antoniovandre/t.txt"$

file_output_append : true$

antoniovandre_primos : matrix ([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]);

antoniovandre_max_natural : 100$

antoniovandre_simbolonumeracao : matrix ([0, "0"], [1, "1"], [2, "2"], [3, "3"], [4, "4"], [5, "5"], [6, "6"], [7, "7"], [8, "8"], [9, "9"], [10, "a"], [11, "b"], [12, "c"], [13, "d"], [14, "e"], [15, "f"], [16, "g"], [17, "h"], [18, "i"], [19, "j"], [20, "k"], [21, "l"], [22, "m"], [23, "n"], [24, "o"], [25, "p"], [26, "q"], [27, "r"], [28, "s"], [29, "t"], [30, "u"], [31, "v"], [32, "w"], [33, "x"], [34, "y"], [35, "z"], [36, "A"], [37, "B"], [38, "C"], [39, "D"], [40, "E"], [41, "F"], [42, "G"], [43, "H"], [44, "I"], [45, "J"], [46, "K"], [47, "L"], [48, "M"], [49, "N"], [50, "O"], [51, "P"], [52, "Q"], [53, "R"], [54, "S"], [55, "T"], [56, "U"], [57, "V"], [58, "W"], [59, "X"], [60, "Y"], [61, "Z"])$

antoniovandre_stringendmark : "*"$

antoniovandre_tempglobalvariable_1 : 0$

/* Fim setar variáveis globais. */

/* Início carregar packages. */

/* Fim carregar packages. */

/* Início procedimentos iniciais. */

/* Fim procedimentos iniciais. */

/* Raíz enésima. Argumentos: "a" número complexo ou polinômio, "n" número natural. */

antoniovandre_nthroot (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot, ", timedate ())), a ^ (1 / n))$

/* Raíz enésima de um número real, saída float. Argumentos: "a" número real, "n" número natural. */

antoniovandre_nthroot_real_float (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_real_float, ", timedate ())), float (exp (log (a)/n)))$

/* Enésima potência. Argumentos: "a" número complexo ou polinômio, "n" número natural. */

antoniovandre_exp (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp, ", timedate ())), a ^ n)$

/* Enésima potência de um número real, saída float. Argumentos: "a" número real, "n" número natural. */

antoniovandre_exp_real_float (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp_real_float, ", timedate ())), float (exp (n * log (a))))$

/* Raíz enésima simplificada. Argumentos: "a" número natural, "n" número natural. */

antoniovandre_nthroot_simp (a, n) := block ([f1, f2, M, m, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_simp, ", timedate ())), f1 : 1, f2 : 1, M : antoniovandre_dfp (a), m : length (M), for i : 1 thru m do (f1 : f1 * M [i, 1] ^ truncate (M [i, 2] / n), f2 : f2 * (M [i, 1] ^ mod (M [i, 2], n)) ^ (1 / n)), matrix ([f1, f2]))$

/* Raíz enésima simplificada com saída formatada. Argumentos: "a" número natural, "n" número natural. */

antoniovandre_nthroot_simp_format (a, n) := block ([M, s, s2], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_simp_format, ", timedate ())), M : antoniovandre_nthroot_simp (a, n), if M [1, 2] = 1 then s : string (M [1, 1]) else (s2 : concat (string (M [1, 2] ^ n), "^(1/", string (n), ")"), s : concat (string (M[1, 1]), concat ("(", s2, ")"))), s)$

/* Raízes enésimas de um número complexo. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_nthroot_complex (z, n) := block ([m, a, mo, ao, k, i, r], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_complex, ", timedate ())), m : abs (z), a : carg (z), mo : m ^ (1 / n), ao : (a + 2 * k * %pi) / n, r : zeromatrix (n, 1), for i : 0 thru n - 1 do r [i + 1, 1] : mo * (cos (ev (ao, k = i)) + %i * sin (ev (ao, k = i))), r)$

/* Raízes enésimas de um número complexo, saídas float. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_nthroot_complex_float (z, n) := block ([m, a, mo, ao, k, i, r], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_complex_float, ", timedate ())), m : abs (z), a : carg (z), mo : antoniovandre_nthroot_real_float (m, n), ao : (a + 2 * k * %pi) / n, r : zeromatrix (n, 1), for i : 0 thru n - 1 do r [i + 1, 1] : mo * float (cos (ev (ao, k = i))) + %i * mo * float (sin (ev (ao, k = i))), r)$

/* Enésima potência de um número complexo. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_exp_complex (z, n) := block ([m, a, mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp_complex, ", timedate ())), m : abs (z), a : carg (z), mo : m ^ n, mo * (cos (a * n) + %i  * sin (a * n)))$

/* Enésima potência de um número complexo, saída float. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_exp_complex_float (z, n) := block ([m, a, mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp_complex_float, ", timedate ())), m : abs (z), a : carg (z), mo : antoniovandre_exp_real_float (m, n), mo * float (cos (a * n)) + %i * mo * float (sin (a * n)))$

/* Fórmula do cosseno de nx. Argumento: "n" número natural. A variável "x" é exportada com fins úteis, como no uso da função "ev". */

antoniovandre_cos_formula_nx (n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cos_formula_nx, ", timedate ())), realpart ((cos (x) + %i * sin (x))^n))$

/* Fórmula do seno de nx. Argumento: "n" número natural. A variável "x" é exportada com fins úteis, como no uso da função "ev". */

antoniovandre_sin_formula_nx (n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sin_formula_nx, ", timedate ())), imagpart ((cos (x) + %i * sin (x))^n))$

/* Cosseno arco-n-metade. Argumentos: "a" número real, "n" número natural. */

antoniovandre_cos_div2pn (a, n) := block ([r, i, j, f, k, seek : 20], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cos_div2pn, ", timedate ())), r : cos (a), for i : 1 thru n do (f : 1, for j : - seek thru seek do if (a / (2 * i) > ev (- %pi / 2 + 2 * k * %pi, k = j)) and (a / (2 * i) < ev (%pi / 2 + 2 * k * %pi, k = j)) then f : 2, r : (-1) ^ f * sqrt (ratsimp (expand ((r + 1) / 2)))), r)$

/* Seno arco-n-metade. Argumentos: "a" número real, "n" número natural. */

antoniovandre_sin_div2pn (a, n) := block ([r, i, j, f, f2, k, seek : 20], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sin_div2pn, ", timedate ())), r : sin (a), for i : 1 thru n do (f : 1, for j : - seek thru seek do if (a / (2 * i) > ev (2 * k * %pi, k = j)) and (a / (2 * i) < ev (%pi + 2 * k * %pi, k = j)) then f : 2, f2 : 1, for j : - seek thru seek do if (a / i > ev (- %pi / 2 + 2 * k * %pi, k = j)) and (a / i < ev (%pi / 2 + 2 * k * %pi, k = j)) then f2 : 2, r : (-1) ^ f * sqrt (ratsimp (expand ((1 - (-1) ^ f2 * sqrt (ratsimp (expand (1 - r ^ 2)))) / 2)))), r)$

/* Cosseno de "a" dividido por "n" com expressão a mais explícita possível segundo Antonio Vandré. Argumentos: "a" número real, "n" número natural. */

antoniovandre_cos_divneav (a, n) := block ([r, P, lP, fde, f, i, k, l, v, x, cosseno, expr, seek : 20, d, dc, di], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cos_divneav, ", timedate ())), P : antoniovandre_dfp (n), lP : length (P), fde : 1, for i : 1 thru lP do if P [i, 1] = 2 then fde : 1 * P [i, 2], f : 1, for i : - seek thru seek do if (a / (n / 2 ^ (fde - 1)) > ev (2 * k * %pi, k = i)) and (a / (n / 2 ^ (fde - 1)) < ev (%pi + 2 * k * %pi, k = i)) then f : 2, expr : cos (a) = subst (((-1) ^ f * sqrt (1 - cos (x) ^ 2)), sin (x), antoniovandre_cos_formula_nx (n / 2 ^ (fde - 1))), expr : subst (cosseno, cos (x), expr), v : solve (expr, cosseno), l : length (v), d : 2, di : 1, for i : 1 thru l do (v [i] : rhs (v [i]), dc : abs (float (v [i]) - float (cos (a / (n / 2 ^ (fde - 1))))), if dc < d then (d : dc, di : i)), if not listofvars (v) = [cosseno] then r : antoniovandre_cos_div2pn (acos (1 * v [di]), fde - 1) else r : cos (a / n), r)$

/* Seno de "a" dividido por "n" com expressão a mais explícita possível segundo Antonio Vandré. Argumentos: "a" número real, "n" número natural. */

antoniovandre_sin_divneav (a, n) := block ([r, P, lP, fde, f, i, k, l, v, x, seno, expr, seek : 20, d, dc, di], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sin_divneav, ", timedate ())), P : antoniovandre_dfp (n), lP : length (P), fde : 1, for i : 1 thru lP do if P [i, 1] = 2 then fde : 1 * P [i, 2], f : 1, for i : - seek thru seek do if (a / (n / 2 ^ (fde - 1)) > ev (- %pi / 2 + 2 * k * %pi, k = i)) and (a / (n / 2 ^ (fde - 1)) < ev (%pi / 2 + 2 * k * %pi, k = i)) then f : 2, expr : cos (a) = subst (((-1) ^ f * sqrt (1 - sin (x) ^ 2)), cos (x), antoniovandre_cos_formula_nx (n / 2 ^ (fde - 1))), expr : subst (seno, sin (x), expr), v : solve (expr, seno), l : length (v), d : 2, di : 1, for i : 1 thru l do (v [i] : rhs (v [i]), dc : abs (float (v [i]) - float (sin (a / (n / 2 ^ (fde - 1))))), if dc < d then (d : dc, di : i)), if not listofvars (v) = [seno] then r : antoniovandre_sin_div2pn (asin (1 * v [di]), fde - 1) else r : sin (a / n), r)$

/* Resolução de um sistema linear com 2 equações e 2 incógnitas pelo método de Cramer. Argumentos: "A" matriz quadrada 2x2, "b" matriz-coluna de 2 linhas.*/

antoniovandre_sqlinsolve_cramer_2 (A, b) := block ([D, Dx, Dy, x, y], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sqlinsolve_cramer_2, ", timedate ())), D : A [1, 1] * A [2, 2] - A [1, 2] * A [2, 1], Dx : b [1, 1] * A [2, 2] - A [1, 2] * b [2, 1], Dy : A [1, 1] * b [2, 1] - b [1, 1] * A [2, 1], x : Dx / D, y : Dy / D, matrix ([x], [y]))$

/* Resolução de um sistema linear com o mesmo número de equações e incógnitas pelo método de Cramer. Argumentos: "A" matriz quadrada nxn, "b" matriz-coluna de n linhas. */

antoniovandre_sqlinsolve_cramer (A, b) := block ([D, s, X, j, Ai, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sqlinsolve_cramer, ", timedate ())), D : antoniovandre_determinante (A), s : length (A), X : zeromatrix (s, 1), for j : 1 thru s do (Ai : 1 * A, for i : 1 thru s do Ai [i, j] : b [i, 1], X [j, 1] : antoniovandre_determinante (Ai) / D), X)$

/* Resolução de um sistema linear pelo método de Gauss. Argumentos: "A" matriz de m linhas, "b" matriz-coluna de m linhas. */

antoniovandre_linsolve_gauss (A, b) := block ([M, m, n, i, j, k, l, f, c1, c2], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_linsolve_gauss, ", timedate ())), M : antoniovandre_addcol (A, b), m : length (M), n : length (transpose (M)), for i : 1 thru m do (k : 1, f : 0, for j : 1 thru n - 1 do if (f = 0) and (not M [i, j] = 0) then (k : j, c1 : 1 * M [i, j], f : 1), if f = 1 then (for j : 1 thru n do M [i, j] : M [i, j] / c1, for l : 1 thru m do if not l = i then (c2 : 1 * M [l, k], for j : 1 thru n do M [l, j] : M [l, j] - c2 * M [i, j]))), M)$

/* Resolução de um sistema linear pelo método de Gauss, com saída formatada. Argumentos: "A" matriz, "b" matriz-coluna. */

antoniovandre_linsolve_gauss_format (A, b) := block ([M, m, n, o, s, i, j, f1, f2, f3], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_linsolve_gauss_format, ", timedate ())), s : "", m : length (A), n : length (b), if not m = n then s : "A matriz incompleta dos coeficientes e a matriz dos coeficientes independentes devem ter o mesmo número de linhas." else (M : antoniovandre_linsolve_gauss (A, b), o : length (transpose (M)), f2 : 0, for i : 1 thru m do (f1 : 0, for j : 1 thru o - 1 do if not M [i, j] = 0 then f1 : 1, if (f1 = 0) and (not M [i, o] = 0) then (s : "Sistema impossível.", f2 : 1)), p : length (antoniovandre_elzf (M)), f3 : 0, if (f2 = 0) and (p < o - 1) then (s : sconcat ("Sistema indeterminado, com grau de indeterminação ", o - 1 - p, "."), f3 : 1), if (f2 = 0) and (f3 = 0) then if p = 1 then s : sconcat ("Raíz: ", 1 * M [1, o], ".") else (s : "Raízes: ", for i : 1 thru p - 1 do s : sconcat (s, 1 * M [i, o], ","), s : sconcat (s, 1 * M [p, o], "."))), s)$

/* Retorna uma matriz qualquer completada com elementos para tornar-se quadrada. Argumento: "M" matriz. */

antoniovandre_sqmatrix (M) := block ([n, m, Mo, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sqmatrix, ", timedate ())), n : length (M), m : length (transpose (M)), if n < m then (Mo : zeromatrix (m, m), for i : 1 thru n do for j : 1 thru m do Mo [i, j] : 1 * M [i, j], for i : n + 1 thru m do for j : 1 thru m do Mo [i, j] : a_(i, j)) else (Mo : zeromatrix (n, n), for i : 1 thru n do for j : 1 thru m do Mo [i, j] : 1 * M [i, j], for i : 1 thru n do for j : m + 1 thru n do Mo [i, j] : a_(i, j)), Mo)$

/* Decomposição em fatores primos. Argumento: "n" número natural. */

antoniovandre_dfp (n) := block ([n2, l, p, i, j, n3, o, n4], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dfp, ", timedate ())), if n = 1 then o : matrix ([1, 1]) else (n2 : n, l : ceiling ((n + 1) / 2), p : zeromatrix (n, 1), for i : 2 thru l do (for j : 1 while mod (n2, i) = 0 do (n2 : n2 / i, p [i, 1] : p [i, 1] + 1), if n2 = 1 then break, n3 : 0, for i : 2 thru n do if not p [i, 1] = 0 then n3 : n3 + 1, o : zeromatrix (n3, 2), n4 : 0, for i : 2 thru n do if not p [i, 1] = 0 then (n4 : n4 + 1, o [n4, 1] : i, o [n4, 2] : p [i, 1]))), o)$

/* Adiciona a linha v ao final da matriz M. Argumentos: "M" matriz de n colunas, "v" matriz-linha de n colunas.*/

antoniovandre_addrow (M, v) := block ([m, n, R, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_addrow, ", timedate ())), m : length (M), n : length (transpose (M)), R : zeromatrix (m + 1, n), for i : 1 thru m do for j : 1 thru n do R [i, j] : 1 * M [i, j], for i : 1 thru n do R [m + 1, i] : 1 * v [1, i], R)$

/* Adiciona a coluna v ao final da matriz M. Argumentos: "M" matriz de m linhas, "v" matriz-coluna de m linhas. */

antoniovandre_addcol (M, v) := block ([m, n, R, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_addcol, ", timedate ())), m : length (M), n : length (transpose (M)), R : zeromatrix (m, n + 1), for i : 1 thru m do for j : 1 thru n do R [i, j] : 1 * M [i, j], for i : 1 thru m do R [i, n + 1] : 1 * v [i, 1], R)$

/* Mínimo múltiplo comum dos elementos da matriz-coluna N. Argumento: "N" matriz-coluna de números naturais. */

antoniovandre_mmc (N) := block ([n, d, v, k, i, j, mmc], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_mmc, ", timedate ())), n : length (N), d : zeromatrix (n, 1), v : matrix ([2, 0]), for i : 1 thru n do (d [i, 1] : antoniovandre_dfp (N [i, 1]), for j : 1 thru length (d [i, 1]) do (f : 0, for k : 1 thru length (v) do if v [k, 1] = d [i, 1] [j, 1] then (f : 1, if v [k, 2] < d [i, 1] [j, 2] then v [k, 2] : 1 * d [i, 1] [j, 2]), if f = 0 then v : antoniovandre_addrow (v, matrix ([1 * d [i, 1] [j, 1], 1 * d [i, 1] [j, 2]])))), mmc : 1, for i : 1 thru length (v) do mmc : mmc * (v [i, 1] ^ v [i, 2]), mmc)$

/* Máximo divisor comum dos elementos da matriz-coluna N. Argumento: "N" matriz-coluna de números naturais. */

antoniovandre_mdc (N) := block ([n, d, m, k, i, j, mdc], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_mdc, ", timedate ())), n : length (N), d : zeromatrix (n, 1), v : matrix ([2, 0]), for i : 1 thru n do d [i, 1] : antoniovandre_dfp (N [i, 1]), mdc : 1, for j : 1 thru length (d [1, 1]) do (f : 0, m : 0, for i : 1 thru n do for k : 1 thru length (d [i, 1]) do if d [1, 1] [j, 1] = d [i, 1] [k, 1] then (f : f +1, if m > d [i, 1] [j, 2] or m = 0 then m : d [i, 1] [j, 2]), if f = n then mdc : mdc * (d [1, 1] [j, 1] ^ m)), mdc)$

/* Probabilidade de cada um dos elementos da matriz-coluna E no espaço amostral matriz-coluna A. Argumentos: "E" matriz-coluna, "A" matriz-coluna. */

antoniovandre_probabilidade (E, A) := block([a, e, p, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_probabilidade, ", timedate ())), a : length (A), e : length (E), p : zeromatrix (e, 3), for i : 1 thru e do p [i, 1] : E [i, 1], for i : 1 thru e do for j : 1 thru a do if A [j, 1] = E [i, 1] then p [i, 2] : p [i, 2] + 1, for i : 1 thru e do p [i, 3] : p [i, 2] / a, p)$

/* Conversão de um número para um símbolo. Função auxiliar da antoniovandre_cnb. Argumento: "n" número natural que possui correspondente em "antoniovandre_simbolonumeracao". */

antoniovandre_nb (n) := block ([r, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nb, ", timedate ())), for i : 1 thru length (antoniovandre_simbolonumeracao) do if n = antoniovandre_simbolonumeracao [i, 1] then r : antoniovandre_simbolonumeracao [i, 2], r)$

/* Conversão de um símbolo para um número. Função auxiliar da antoniovandre_cnb. Argumento: "s" string que possui correspondente em "antoniovandre_simbolonumeracao". */

antoniovandre_nbr (s) := block ([n, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nbr, ", timedate ())), for i : 1 thru length (antoniovandre_simbolonumeracao) do if s = antoniovandre_simbolonumeracao [i, 2] then n : antoniovandre_simbolonumeracao [i, 1], n)$

/* Tamanho de uma string. Argumento: "s" string. */

antoniovandre_stringlength (s) := block ([sb, n, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_stringlength, ", timedate ())), sb : concat (s, antoniovandre_stringendmark), n : 1, for i : 1 while not substring (sb, n, n + 1) = antoniovandre_stringendmark do n : n + 1, n - 1)$

/* Substring entre os índices "inicio" e "fim". Argumentos: "s" string, "inicio" número natural, "fim" número natural. */

antoniovandre_substring (s, inicio, fim) := block ([i, sub, f], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_substring, ", timedate ())), sub : "", if inicio < antoniovandre_stringlength (s) then (f : min (fim, antoniovandre_stringlength (s) - 1), for i : inicio thru f do sub : concat (sub, s [i])), sub)$

/* Conversão de números entre bases de numeração. Argumentos: "n" string, "b1" número natural que possui correspondente em "antoniovandre_simbolonumeracao", "b2" número natural que possui correspondente em "antoniovandre_simbolonumeracao". */

antoniovandre_cnb (n, b1, b2) := block ([s, q1, i, n2, nb, q2, c], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cnb, ", timedate ())), s : "", nb : 0, q1 : antoniovandre_stringlength (n), for i : 1 thru q1 do nb : nb + antoniovandre_nbr (antoniovandre_substring (n, i - 1, i - 1)) * b1 ^ (q1 - i), n2 : nb, q2 : truncate (log (nb) / log (b2)) + 1, for i : 1 thru q2 do (c : truncate (n2 / b2 ^ (q2 - i)), s : concat (s, antoniovandre_nb(c)), n2 : mod (n2, c * b2 ^ (q2 - i))), s)$

/* Ocorrências da substring "sub" dentro da string "s". Argumentos: "s" string, "sub" string. Retorna uma matriz de duas colunas contendo, em cada linha, os índices inicial e final de cada ocorrência. */

antoniovandre_substrings (s, sub) := block ([l, l2, i, c, strs], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_substrings, ", timedate ())), l : antoniovandre_stringlength (s), l2 : antoniovandre_stringlength (sub), strs : zeromatrix (l, 2), c : 0, for i : 0 thru l - 1 do if antoniovandre_substring (s, i, i + l2 - 1) = sub then (c : c + 1, strs [c, 1] : i + 1, strs [c, 2] : i + l2), antoniovandre_elzf (strs) - 1)$

/* Substring da n-ésima ocorrência entre tokens. Argumentos: "s" string, "t" string, "n" número natural. */

antoniovandre_snt (s, t, n, modo) := block ([l, l2, i, o, c, p, so], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_snt, ", timedate ())), so : "", l : antoniovandre_stringlength (s), l2 : antoniovandre_stringlength (t), o : zeromatrix (1, 2), c : 0, p : 0, for i : 0 thru l - 1 do if (antoniovandre_substring (s, i, i + l2 - 1) = t or i = l - 1) then (o [1, 1] : 1 * o [1, 2], o [1, 2] : 1 * (i + l2), c : c + 1, if (modo = "i" and i = l - 1 and c = n) then p : l + l2 - o [1, 2], if (modo = "i" and c = n) or (modo = "c" and c - 1 = n) or (modo = "s" and c / 2 = n) then so : antoniovandre_substring (s, 1 * o [1, 1], o [1, 2] - l2 - 1 + p)), so)$

/* Eliminar linhas nulas no final de uma matriz. Argumento: "M" matriz. */

antoniovandre_elzf (M) := block ([n, m, s, l, i, j, Mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_elzf, ", timedate ())), n : length (M), m : length (transpose (M)), l : 0, for i : 1 thru n do (s : 0, for j : 1 thru m do s : s + M [n - i + 1, j], if s = 0 then l : l + 1), Mo : zeromatrix (n - l, m), for i : 1 thru n - l do for j : 1 thru m do Mo [i, j] : 1 * M [i, j], Mo)$

/* Divisão de polinômios em 1 variável. Argumentos: "P" polinômio, "D" polinômio. */

antoniovandre_dp1v (P, D) := block ([n, m, Q, R, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dp1v, ", timedate ())), n : length (P), m : length (D), Q : zeromatrix (n - m + 1, 1), R : 1 * P, for i : 0 thru n - m do (Q [n - m - i + 1, 1] : R [n - i, 1] / D [m, 1], for j : 1 thru m do R [n - i - j + 1, 1] : R [n - i - j + 1, 1] - Q [n - m - i + 1, 1] * D [m - j + 1, 1]), R: antoniovandre_elzf (R), matrix ([Q, R]))$

/* Verificar se uma matriz é nula. Argumento: "M" matriz. */

antoniovandre_matrixzero (M) := block ([n, m, i, j, s, o], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_matrixzero, ", timedate ())), n : length (M), m : length (transpose (M)), s : 0, for i : 1 thru n do for j : 1 thru m do s : s + M [i, j], if s = 0 then o : true else o : false, o)$

/* Divisão de polinômios em 1 variável, com saída formatada. Argumentos: "P" polinômio, "D" polinômio. */

antoniovandre_dp1v_format (P, D) := block ([M, di, dv, q, r, i, x, s, plus], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dp1v_format, ", timedate ())), s : "", M : antoniovandre_dp1v (P, D), di : length (P), dv : length (D), q: length (M [1, 1]), r : length (M [1, 2]), for i : 1 thru di do if not P [di - i + 1, 1] = 0 then (if (i = 1) or (P [di - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, P [di - i + 1, 1] * x^(di - i))), s : sconcat (s, " = ("), for i : 1 thru dv do if not D [dv - i + 1, 1] = 0 then (if (i = 1) or (D [dv - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, D [dv - i + 1, 1] * x^(dv - i))), s : sconcat (s, ")("), for i : 1 thru q do if not M [1, 1] [q - i + 1, 1] = 0 then (if (i = 1) or (M [1, 1] [q - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, M [1, 1] [q - i + 1, 1] * x^(q - i))), s : sconcat (s, ") + "), if antoniovandre_matrixzero (M [1, 2]) then s : sconcat (s, "0") else for i : 1 thru r do if not M [1, 2] [r - i + 1, 1] = 0 then (if (i = 1) or (M [1, 2] [r - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, M [1, 2] [r - i + 1, 1] * x^(r - i))), s)$

/* Fatorial. Argumento: "n" número natural. */

antoniovandre_fatorial (n) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes and n = 0 then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_fatorial, ", timedate ())), if n > 0 then n * antoniovandre_fatorial (n - 1) else 1)$

/* Remover linha "i" e coluna "j" da matriz. Argumentos: "M" matriz, "i" número natural, "j" número natural. */

antoniovandre_rmlc (M, i, j) := block ([l, l2, k, k2, c, c2, Mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_rmlc, ", timedate ())), l : length (M), l2 : length (transpose (M)), Mo : zeromatrix (l - 1, l2 - 1), c : 0, for k : 1 thru l do if not k = i then (c : c + 1, c2 : 0, for k2 : 1 thru l2 do if not k2 = j then (c2 : c2 + 1, Mo [c, c2] : 1 * M [k, k2])), Mo)$

/* Determinante sem armazenamento de estatísticas. Função auxiliar de "antoniovandre_determinante". Argumento: "M" matriz quadrada. */

antoniovandre_det (M) := block ([l, i, d], l : length (M), d : 0, if l > 1 then for i : 1 thru l do d : d + M [i, 1] * (-1) ^ (i + 1) * antoniovandre_det (antoniovandre_rmlc (M, i, 1)) else d : 1 * M [1, 1], d)$

/* Determinante. Argumento: "M" matriz quadrada. */

antoniovandre_determinante (M) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_determinante, ", timedate ())), antoniovandre_det (M))$

/* Arranjos de "n" elementos tomados "p" a "p". Argumentos: "n" número natural, "p" número natural menor ou igual a "n". */

antoniovandre_arranjos (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_arranjos, ", timedate ())), antoniovandre_fatorial (n) / antoniovandre_fatorial (n - p))$

/* Arranjos de "n" elementos tomados "p" a "p". Argumentos: "n" número natural, "p" número natural menor ou igual a "n". */

antoniovandre_arranjosrepeticao (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_arranjosrepeticao, ", timedate ())), n ^ p)$

/* Combinações de "n" elementos tomados "p" a "p". Argumentos: "n" número natural, "p" número natural menor ou igual a "n". */

antoniovandre_combinacoes (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_combinacoes, ", timedate ())), antoniovandre_arranjos (n, p) / antoniovandre_fatorial (p))$

/* Combinações com repetição de "n" elementos tomados "p" a "p". Argumentos: "n" número natural não nulo, "p" número natural menor ou igual a "n". */

antoniovandre_combinacoesrepeticao (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_combinacoesrepeticao, ", timedate ())), antoniovandre_fatorial (n + p - 1) / (antoniovandre_fatorial (p) * antoniovandre_fatorial (n - 1)))$

/* Permutações de "n" elementos. Argumento: "n" número natural. */

antoniovandre_permutacoes (n) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_permutacoes, ", timedate ())), antoniovandre_fatorial (n))$

/* Permutações com repetição de "n" elementos, em que um ou mais elementos são repetidos com os números de repetições que estão no vetor-linha "r". Argumentos: "n" número natural, "r" vetor-linha cuja soma dos elementos não ultrapasse "n". */

antoniovandre_permutacoes (n, r) := block ([l, i, f], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_permutacoesrepeticao, ", timedate ())), l : length (transpose (r)), f : 1, for i : 1 thru l do f : f * antoniovandre_fatorial (r [1, i]), antoniovandre_fatorial (n) / f)$

/* Início funções e procedimentos em desenvolvimento.

Fim funções e procedimentos em desenvolvimento. */

/* Fim funções e procedimentos programados por Antonio Vandré Pedrosa Furtunato Gomes. */

