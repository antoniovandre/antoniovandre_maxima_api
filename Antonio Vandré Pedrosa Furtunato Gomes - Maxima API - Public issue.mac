/*
API Maxima de Antonio Vandré Pedrosa Furtunato Gomes (http://bit.ly/antoniovandre_legadoontologico) - Antonio Vandré Pedrosa Furtunato Gomes Android issue.

Pode ser necessária permissão para escrever em dispositivo.

Última atualização: 18-07-2019.
*/

/* Início funções e procedimentos programados por terceiros. */

/* Fim funções e procedimentos programados por terceiros. */

/* Início funções e procedimentos programados por Antonio Vandré Pedrosa Furtunato Gomes. */

/* Início setar variáveis globais. */

antoniovandre_armazenar_estatisticas_uso_funcoes : false$

antoniovandre_arquivo_estatisticas_funcoes : "maxima_history.txt"$

antoniovandre_arquivo_grafico_estatisticas_funcoes : "maxima_history.png"$ /* Requer outros softwares para processamento. */

antoniovandre_tempfile_1 : "mt1"$

antoniovandre_tempfile_2 : "mt2"$

antoniovandre_tempfile_3 : "mt3"$

antoniovandre_testfile : "t.txt"$

file_output_append : true$

antoniovandre_primos : matrix ([2 ,3 ,5 ,7 ,11 ,13 ,17 ,19 ,23 ,29 ,31 ,37 ,41 ,43 ,47 ,53 ,59 ,61 ,67 ,71 ,73 ,79 ,83 ,89 ,97 ,101 ,103 ,107 ,109 ,113 ,127 ,131 ,137 ,139 ,149 ,151 ,157 ,163 ,167 ,173 ,179 ,181 ,191 ,193 ,197 ,199 ,211 ,223 ,227 ,229 ,233 ,239 ,241 ,251 ,257 ,263 ,269 ,271 ,277 ,281 ,283 ,293 ,307 ,311 ,313 ,317 ,331 ,337 ,347 ,349 ,353 ,359 ,367 ,373 ,379 ,383 ,389 ,397 ,401 ,409 ,419 ,421 ,431 ,433 ,439 ,443 ,449 ,457 ,461 ,463 ,467 ,479 ,487 ,491 ,499 ,503 ,509 ,521 ,523 ,541 ,547 ,557 ,563 ,569 ,571 ,577 ,587 ,593 ,599 ,601 ,607 ,613 ,617 ,619 ,631 ,641 ,643 ,647 ,653 ,659 ,661 ,673 ,677 ,683 ,691 ,701 ,709 ,719 ,727 ,733 ,739 ,743 ,751 ,757 ,761 ,769 ,773 ,787 ,797 ,809 ,811 ,821 ,823 ,827 ,829 ,839 ,853 ,857 ,859 ,863 ,877 ,881 ,883 ,887 ,907 ,911 ,919 ,929 ,937 ,941 ,947 ,953 ,967 ,971 ,977 ,983 ,991 ,997])$

antoniovandre_max_natural : 100$

antoniovandre_simbolonumeracao : matrix ([0, "0"], [1, "1"], [2, "2"], [3, "3"], [4, "4"], [5, "5"], [6, "6"], [7, "7"], [8, "8"], [9, "9"], [10, "a"], [11, "b"], [12, "c"], [13, "d"], [14, "e"], [15, "f"], [16, "g"], [17, "h"], [18, "i"], [19, "j"], [20, "k"], [21, "l"], [22, "m"], [23, "n"], [24, "o"], [25, "p"], [26, "q"], [27, "r"], [28, "s"], [29, "t"], [30, "u"], [31, "v"], [32, "w"], [33, "x"], [34, "y"], [35, "z"], [36, "A"], [37, "B"], [38, "C"], [39, "D"], [40, "E"], [41, "F"], [42, "G"], [43, "H"], [44, "I"], [45, "J"], [46, "K"], [47, "L"], [48, "M"], [49, "N"], [50, "O"], [51, "P"], [52, "Q"], [53, "R"], [54, "S"], [55, "T"], [56, "U"], [57, "V"], [58, "W"], [59, "X"], [60, "Y"], [61, "Z"])$

antoniovandre_stringendmark : "*"$

antoniovandre_tempglobalvariable_1 : 0$

/* Fim setar variáveis globais. */

/* Início carregar packages. */

/* Fim carregar packages. */

/* Início procedimentos iniciais. */

/* Fim procedimentos iniciais. */

/* Raíz enésima. Argumentos: "a" número complexo ou polinômio, "n" número natural. */

antoniovandre_nthroot (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot, ", timedate ())), a ^ (1 / n))$

/* Raíz enésima de um número real, saída float. Argumentos: "a" número real, "n" número natural. */

antoniovandre_nthroot_real_float (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_real_float, ", timedate ())), float (exp (log (a)/n)))$

/* Enésima potência. Argumentos: "a" número complexo ou polinômio, "n" número natural. */

antoniovandre_exp (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp, ", timedate ())), a ^ n)$

/* Enésima potência de um número real, saída float. Argumentos: "a" número real, "n" número natural. */

antoniovandre_exp_real_float (a, n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp_real_float, ", timedate ())), float (exp (n * log (a))))$

/* Raíz enésima simplificada. Argumentos: "a" número natural, "n" número natural. */

antoniovandre_nthroot_simp (a, n) := block ([f1, f2, M, m, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_simp, ", timedate ())), f1 : 1, f2 : 1, M : antoniovandre_dfp (a), m : length (M), for i : 1 thru m do (f1 : f1 * M [i, 1] ^ truncate (M [i, 2] / n), f2 : f2 * (M [i, 1] ^ mod (M [i, 2], n)) ^ (1 / n)), matrix ([f1, f2]))$

/* Raíz enésima simplificada com saída formatada. Argumentos: "a" número natural, "n" número natural. */

antoniovandre_nthroot_simp_format (a, n) := block ([M, s, s2], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_simp_format, ", timedate ())), M : antoniovandre_nthroot_simp (a, n), if M [1, 2] = 1 then s : string (M [1, 1]) else (s2 : concat (string (M [1, 2] ^ n), "^(1/", string (n), ")"), s : concat (string (M[1, 1]), concat ("(", s2, ")"))), s)$

/* Raízes enésimas de um número complexo. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_nthroot_complex (z, n) := block ([m, a, mo, ao, k, i, r], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_complex, ", timedate ())), m : abs (z), a : carg (z), mo : m ^ (1 / n), ao : (a + 2 * k * %pi) / n, r : zeromatrix (n, 1), for i : 0 thru n - 1 do r [i + 1, 1] : mo * (cos (ev (ao, k = i)) + %i * sin (ev (ao, k = i))), r)$

/* Raízes enésimas de um número complexo, saídas float. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_nthroot_complex_float (z, n) := block ([m, a, mo, ao, k, i, r], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nthroot_complex_float, ", timedate ())), m : abs (z), a : carg (z), mo : antoniovandre_nthroot_real_float (m, n), ao : (a + 2 * k * %pi) / n, r : zeromatrix (n, 1), for i : 0 thru n - 1 do r [i + 1, 1] : mo * float (cos (ev (ao, k = i))) + %i * mo * float (sin (ev (ao, k = i))), r)$

/* Enésima potência de um número complexo. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_exp_complex (z, n) := block ([m, a, mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp_complex, ", timedate ())), m : abs (z), a : carg (z), mo : m ^ n, mo * (cos (a * n) + %i  * sin (a * n)))$

/* Enésima potência de um número complexo, saída float. Argumentos: "z" número complexo, "n" número natural. */

antoniovandre_exp_complex_float (z, n) := block ([m, a, mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_exp_complex_float, ", timedate ())), m : abs (z), a : carg (z), mo : antoniovandre_exp_real_float (m, n), mo * float (cos (a * n)) + %i * mo * float (sin (a * n)))$

/* Fórmula do cosseno de nx. Argumento: "n" número natural. A variável "x" é exportada com fins úteis, como no uso da função "ev". */

antoniovandre_cos_formula_nx (n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cos_formula_nx, ", timedate ())), realpart ((cos (x) + %i * sin (x))^n))$

/* Fórmula do seno de nx. Argumento: "n" número natural. A variável "x" é exportada com fins úteis, como no uso da função "ev". */

antoniovandre_sin_formula_nx (n) := block (if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sin_formula_nx, ", timedate ())), imagpart ((cos (x) + %i * sin (x))^n))$

/* Cosseno arco-n-metade. Argumentos: "a" número real, "n" número natural. */

antoniovandre_cos_div2pn (a, n) := block ([r, i, j, f, k, seek : 20], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cos_div2pn, ", timedate ())), r : cos (a), for i : 1 thru n do (f : 1, for j : - seek thru seek do if (a / (2 * i) > ev (- %pi / 2 + 2 * k * %pi, k = j)) and (a / (2 * i) < ev (%pi / 2 + 2 * k * %pi, k = j)) then f : 2, r : (-1) ^ f * sqrt (ratsimp (expand ((r + 1) / 2)))), r)$

/* Seno arco-n-metade. Argumentos: "a" número real, "n" número natural. */

antoniovandre_sin_div2pn (a, n) := block ([r, i, j, f, f2, k, seek : 20], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sin_div2pn, ", timedate ())), r : sin (a), for i : 1 thru n do (f : 1, for j : - seek thru seek do if (a / (2 * i) > ev (2 * k * %pi, k = j)) and (a / (2 * i) < ev (%pi + 2 * k * %pi, k = j)) then f : 2, f2 : 1, for j : - seek thru seek do if (a / i > ev (- %pi / 2 + 2 * k * %pi, k = j)) and (a / i < ev (%pi / 2 + 2 * k * %pi, k = j)) then f2 : 2, r : (-1) ^ f * sqrt (ratsimp (expand ((1 - (-1) ^ f2 * sqrt (ratsimp (expand (1 - r ^ 2)))) / 2)))), r)$

/* Cosseno de "a" dividido por "n" com expressão a mais explícita possível segundo Antonio Vandré. Argumentos: "a" número real, "n" número natural. */

antoniovandre_cos_divneav (a, n) := block ([r, P, lP, fde, f, i, k, l, v, x, cosseno, expr, seek : 20, d, dc, di], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cos_divneav, ", timedate ())), P : antoniovandre_dfp (n), lP : length (P), fde : 1, for i : 1 thru lP do if P [i, 1] = 2 then fde : 1 * P [i, 2], f : 1, for i : - seek thru seek do if (a / (n / 2 ^ (fde - 1)) > ev (2 * k * %pi, k = i)) and (a / (n / 2 ^ (fde - 1)) < ev (%pi + 2 * k * %pi, k = i)) then f : 2, expr : cos (a) = subst (((-1) ^ f * sqrt (1 - cos (x) ^ 2)), sin (x), antoniovandre_cos_formula_nx (n / 2 ^ (fde - 1))), expr : subst (cosseno, cos (x), expr), v : solve (expr, cosseno), l : length (v), d : 2, di : 1, for i : 1 thru l do (v [i] : rhs (v [i]), dc : abs (float (v [i]) - float (cos (a / (n / 2 ^ (fde - 1))))), if dc < d then (d : dc, di : i)), if not listofvars (v) = [cosseno] then r : antoniovandre_cos_div2pn (acos (1 * v [di]), fde - 1) else r : cos (a / n), r)$

/* Seno de "a" dividido por "n" com expressão a mais explícita possível segundo Antonio Vandré. Argumentos: "a" número real, "n" número natural. */

antoniovandre_sin_divneav (a, n) := block ([r, P, lP, fde, f, i, k, l, v, x, seno, expr, seek : 20, d, dc, di], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sin_divneav, ", timedate ())), P : antoniovandre_dfp (n), lP : length (P), fde : 1, for i : 1 thru lP do if P [i, 1] = 2 then fde : 1 * P [i, 2], f : 1, for i : - seek thru seek do if (a / (n / 2 ^ (fde - 1)) > ev (- %pi / 2 + 2 * k * %pi, k = i)) and (a / (n / 2 ^ (fde - 1)) < ev (%pi / 2 + 2 * k * %pi, k = i)) then f : 2, expr : cos (a) = subst (((-1) ^ f * sqrt (1 - sin (x) ^ 2)), cos (x), antoniovandre_cos_formula_nx (n / 2 ^ (fde - 1))), expr : subst (seno, sin (x), expr), v : solve (expr, seno), l : length (v), d : 2, di : 1, for i : 1 thru l do (v [i] : rhs (v [i]), dc : abs (float (v [i]) - float (sin (a / (n / 2 ^ (fde - 1))))), if dc < d then (d : dc, di : i)), if not listofvars (v) = [seno] then r : antoniovandre_sin_div2pn (asin (1 * v [di]), fde - 1) else r : sin (a / n), r)$

/* Resolução de um sistema linear com 2 equações e 2 incógnitas pelo método de Cramer. Argumentos: "A" matriz quadrada 2x2, "b" matriz-coluna de 2 linhas.*/

antoniovandre_sqlinsolve_cramer_2 (A, b) := block ([D, Dx, Dy, x, y], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sqlinsolve_cramer_2, ", timedate ())), D : A [1, 1] * A [2, 2] - A [1, 2] * A [2, 1], Dx : b [1, 1] * A [2, 2] - A [1, 2] * b [2, 1], Dy : A [1, 1] * b [2, 1] - b [1, 1] * A [2, 1], x : Dx / D, y : Dy / D, matrix ([x], [y]))$

/* Resolução de um sistema linear com o mesmo número de equações e incógnitas pelo método de Cramer. Argumentos: "A" matriz quadrada nxn, "b" matriz-coluna de n linhas. */

antoniovandre_sqlinsolve_cramer (A, b) := block ([D, s, X, j, Ai, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sqlinsolve_cramer, ", timedate ())), D : antoniovandre_determinante (A), s : length (A), X : zeromatrix (s, 1), for j : 1 thru s do (Ai : 1 * A, for i : 1 thru s do Ai [i, j] : b [i, 1], X [j, 1] : antoniovandre_determinante (Ai) / D), X)$

/* Resolução de um sistema linear pelo método de Gauss. Argumentos: "A" matriz de m linhas, "b" matriz-coluna de m linhas. */

antoniovandre_linsolve_gauss (A, b) := block ([M, m, n, i, j, k, l, f, c1, c2], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_linsolve_gauss, ", timedate ())), M : antoniovandre_addcol (A, b), m : length (M), n : length (transpose (M)), for i : 1 thru m do (k : 1, f : 0, for j : 1 thru n - 1 do if (f = 0) and (not M [i, j] = 0) then (k : j, c1 : 1 * M [i, j], f : 1), if f = 1 then (for j : 1 thru n do M [i, j] : M [i, j] / c1, for l : 1 thru m do if not l = i then (c2 : 1 * M [l, k], for j : 1 thru n do M [l, j] : M [l, j] - c2 * M [i, j]))), M)$

/* Resolução de um sistema linear pelo método de Gauss, com saída formatada. Argumentos: "A" matriz, "b" matriz-coluna. */

antoniovandre_linsolve_gauss_format (A, b) := block ([M, m, n, o, s, i, j, f1, f2, f3], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_linsolve_gauss_format, ", timedate ())), s : "", m : length (A), n : length (b), if not m = n then s : "A matriz incompleta dos coeficientes e a matriz dos coeficientes independentes devem ter o mesmo número de linhas." else (M : antoniovandre_linsolve_gauss (A, b), o : length (transpose (M)), f2 : 0, for i : 1 thru m do (f1 : 0, for j : 1 thru o - 1 do if not M [i, j] = 0 then f1 : 1, if (f1 = 0) and (not M [i, o] = 0) then (s : "Sistema impossível.", f2 : 1)), p : length (antoniovandre_elzf (M)), f3 : 0, if (f2 = 0) and (p < o - 1) then (s : sconcat ("Sistema indeterminado, com grau de indeterminação ", o - 1 - p, "."), f3 : 1), if (f2 = 0) and (f3 = 0) then if p = 1 then s : sconcat ("Raíz: ", 1 * M [1, o], ".") else (s : "Raízes: ", for i : 1 thru p - 1 do s : sconcat (s, 1 * M [i, o], ","), s : sconcat (s, 1 * M [p, o], "."))), s)$

/* Retorna uma matriz qualquer completada com elementos para tornar-se quadrada. Argumento: "M" matriz. */

antoniovandre_sqmatrix (M) := block ([n, m, Mo, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_sqmatrix, ", timedate ())), n : length (M), m : length (transpose (M)), if n < m then (Mo : zeromatrix (m, m), for i : 1 thru n do for j : 1 thru m do Mo [i, j] : 1 * M [i, j], for i : n + 1 thru m do for j : 1 thru m do Mo [i, j] : a_(i, j)) else (Mo : zeromatrix (n, n), for i : 1 thru n do for j : 1 thru m do Mo [i, j] : 1 * M [i, j], for i : 1 thru n do for j : m + 1 thru n do Mo [i, j] : a_(i, j)), Mo)$

/* Decomposição em fatores primos. Argumento: "n" número natural. */

antoniovandre_dfp (n) := block ([n2, l, flag_p, flag_p_m, p, i, j, n3, o, n4], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dfp, ", timedate ())), if n = 1 then o : matrix ([1, 1]) else (n2 : n, p : zeromatrix (n, 1), l : length (transpose (antoniovandre_primos)), for i : 2 thru n do (flag_p : 0, flag_p_m : 0, for j : 1 thru l do (if antoniovandre_primos [1, j] = 1 * i then (flag_p : 1, return), if (j = l and flag_p = 0) then flag_p_m : 1), if (flag_p = 1 or flag_p_m = 1) then for j : 1 while mod (n2, i) = 0 do (n2 : n2 / i, p [i, 1] : p [i, 1] + 1, if n2 = 1 then return)), n3 : 0, for i : 2 thru n do if not p [i, 1] = 0 then n3 : n3 + 1, o : zeromatrix (n3, 2), n4 : 0, for i : 2 thru n do if not p [i, 1] = 0 then (n4 : n4 + 1, o [n4, 1] : i, o [n4, 2] : p [i, 1])), o)$

/* Adiciona a linha v ao final da matriz M. Argumentos: "M" matriz de n colunas, "v" matriz-linha de n colunas.*/

antoniovandre_addrow (M, v) := block ([m, n, R, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_addrow, ", timedate ())), m : length (M), n : length (transpose (M)), R : zeromatrix (m + 1, n), for i : 1 thru m do for j : 1 thru n do R [i, j] : 1 * M [i, j], for i : 1 thru n do R [m + 1, i] : 1 * v [1, i], R)$

/* Adiciona a coluna v ao final da matriz M. Argumentos: "M" matriz de m linhas, "v" matriz-coluna de m linhas. */

antoniovandre_addcol (M, v) := block ([m, n, R, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_addcol, ", timedate ())), m : length (M), n : length (transpose (M)), R : zeromatrix (m, n + 1), for i : 1 thru m do for j : 1 thru n do R [i, j] : 1 * M [i, j], for i : 1 thru m do R [i, n + 1] : 1 * v [i, 1], R)$

/* Mínimo múltiplo comum dos elementos da matriz-coluna N. Argumento: "N" matriz-coluna de números naturais. */

antoniovandre_mmc (N) := block ([n, d, v, k, i, j, mmc], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_mmc, ", timedate ())), n : length (N), d : zeromatrix (n, 1), v : matrix ([2, 0]), for i : 1 thru n do (d [i, 1] : antoniovandre_dfp (N [i, 1]), for j : 1 thru length (d [i, 1]) do (f : 0, for k : 1 thru length (v) do if v [k, 1] = d [i, 1] [j, 1] then (f : 1, if v [k, 2] < d [i, 1] [j, 2] then v [k, 2] : 1 * d [i, 1] [j, 2]), if f = 0 then v : antoniovandre_addrow (v, matrix ([1 * d [i, 1] [j, 1], 1 * d [i, 1] [j, 2]])))), mmc : 1, for i : 1 thru length (v) do mmc : mmc * (v [i, 1] ^ v [i, 2]), mmc)$

/* Máximo divisor comum dos elementos da matriz-coluna N. Argumento: "N" matriz-coluna de números naturais. */

antoniovandre_mdc (N) := block ([n, d, m, k, i, j, mdc], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_mdc, ", timedate ())), n : length (N), d : zeromatrix (n, 1), v : matrix ([2, 0]), for i : 1 thru n do d [i, 1] : antoniovandre_dfp (N [i, 1]), mdc : 1, for j : 1 thru length (d [1, 1]) do (f : 0, m : 0, for i : 1 thru n do for k : 1 thru length (d [i, 1]) do if d [1, 1] [j, 1] = d [i, 1] [k, 1] then (f : f +1, if m > d [i, 1] [j, 2] or m = 0 then m : d [i, 1] [j, 2]), if f = n then mdc : mdc * (d [1, 1] [j, 1] ^ m)), mdc)$

/* Probabilidade de cada um dos elementos da matriz-coluna E no espaço amostral matriz-coluna A. Argumentos: "E" matriz-coluna, "A" matriz-coluna. */

antoniovandre_probabilidade (E, A) := block([a, e, p, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_probabilidade, ", timedate ())), a : length (A), e : length (E), p : zeromatrix (e, 3), for i : 1 thru e do p [i, 1] : E [i, 1], for i : 1 thru e do for j : 1 thru a do if A [j, 1] = E [i, 1] then p [i, 2] : p [i, 2] + 1, for i : 1 thru e do p [i, 3] : p [i, 2] / a, p)$

/* Conversão de um número para um símbolo. Função auxiliar da antoniovandre_cnb. Argumento: "n" número natural que possui correspondente em "antoniovandre_simbolonumeracao". */

antoniovandre_nb (n) := block ([r, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nb, ", timedate ())), for i : 1 thru length (antoniovandre_simbolonumeracao) do if n = antoniovandre_simbolonumeracao [i, 1] then r : antoniovandre_simbolonumeracao [i, 2], r)$

/* Conversão de um símbolo para um número. Função auxiliar da antoniovandre_cnb. Argumento: "s" string que possui correspondente em "antoniovandre_simbolonumeracao". */

antoniovandre_nbr (s) := block ([n, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_nbr, ", timedate ())), for i : 1 thru length (antoniovandre_simbolonumeracao) do if s = antoniovandre_simbolonumeracao [i, 2] then n : antoniovandre_simbolonumeracao [i, 1], n)$

/* Tamanho de uma string. Argumento: "s" string. */

antoniovandre_stringlength (s) := block ([sb, n, i], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_stringlength, ", timedate ())), sb : concat (s, antoniovandre_stringendmark), n : 1, for i : 1 while not substring (sb, n, n + 1) = antoniovandre_stringendmark do n : n + 1, n - 1)$

/* Substring entre os índices "inicio" e "fim". Argumentos: "s" string, "inicio" número natural, "fim" número natural. */

antoniovandre_substring (s, inicio, fim) := block ([i, sub, f], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_substring, ", timedate ())), sub : "", if inicio < antoniovandre_stringlength (s) then (f : min (fim, antoniovandre_stringlength (s) - 1), for i : inicio thru f do sub : concat (sub, s [i])), sub)$

/* Conversão de números entre bases de numeração. Argumentos: "n" string, "b1" número natural que possui correspondente em "antoniovandre_simbolonumeracao", "b2" número natural que possui correspondente em "antoniovandre_simbolonumeracao". */

antoniovandre_cnb (n, b1, b2) := block ([s, q1, i, n2, nb, q2, c], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_cnb, ", timedate ())), s : "", nb : 0, q1 : antoniovandre_stringlength (n), for i : 1 thru q1 do nb : nb + antoniovandre_nbr (antoniovandre_substring (n, i - 1, i - 1)) * b1 ^ (q1 - i), n2 : nb, q2 : truncate (log (nb) / log (b2)) + 1, for i : 1 thru q2 do (c : truncate (n2 / b2 ^ (q2 - i)), s : concat (s, antoniovandre_nb(c)), n2 : mod (n2, c * b2 ^ (q2 - i))), s)$

/* Ocorrências da substring "sub" dentro da string "s". Argumentos: "s" string, "sub" string. Retorna uma matriz de duas colunas contendo, em cada linha, os índices inicial e final de cada ocorrência. */

antoniovandre_substrings (s, sub) := block ([l, l2, i, c, strs], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_substrings, ", timedate ())), l : antoniovandre_stringlength (s), l2 : antoniovandre_stringlength (sub), strs : zeromatrix (l, 2), c : 0, for i : 0 thru l - 1 do if antoniovandre_substring (s, i, i + l2 - 1) = sub then (c : c + 1, strs [c, 1] : i + 1, strs [c, 2] : i + l2), antoniovandre_elzf (strs) - 1)$

/* Substring da n-ésima ocorrência entre tokens. Argumentos: "s" string, "t" string, "n" número natural. */

antoniovandre_snt (s, t, n, modo) := block ([l, l2, i, o, c, p, so], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_snt, ", timedate ())), so : "", l : antoniovandre_stringlength (s), l2 : antoniovandre_stringlength (t), o : zeromatrix (1, 2), c : 0, p : 0, for i : 0 thru l - 1 do if (antoniovandre_substring (s, i, i + l2 - 1) = t or i = l - 1) then (o [1, 1] : 1 * o [1, 2], o [1, 2] : 1 * (i + l2), c : c + 1, if (modo = "i" and i = l - 1 and c = n) then p : l + l2 - o [1, 2], if (modo = "i" and c = n) or (modo = "c" and c - 1 = n) or (modo = "s" and c / 2 = n) then so : antoniovandre_substring (s, 1 * o [1, 1], o [1, 2] - l2 - 1 + p)), so)$

/* Eliminar linhas nulas no final de uma matriz. Argumento: "M" matriz. */

antoniovandre_elzf (M) := block ([n, m, s, l, i, j, Mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_elzf, ", timedate ())), n : length (M), m : length (transpose (M)), l : 0, for i : 1 thru n do (s : 0, for j : 1 thru m do s : s + M [n - i + 1, j], if s = 0 then l : l + 1), Mo : zeromatrix (n - l, m), for i : 1 thru n - l do for j : 1 thru m do Mo [i, j] : 1 * M [i, j], Mo)$

/* Divisão de polinômios em 1 variável. Argumentos: "P" polinômio, "D" polinômio. */

antoniovandre_dp1v (P, D) := block ([n, m, Q, R, i, j], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dp1v, ", timedate ())), n : length (P), m : length (D), Q : zeromatrix (n - m + 1, 1), R : 1 * P, for i : 0 thru n - m do (Q [n - m - i + 1, 1] : R [n - i, 1] / D [m, 1], for j : 1 thru m do R [n - i - j + 1, 1] : R [n - i - j + 1, 1] - Q [n - m - i + 1, 1] * D [m - j + 1, 1]), R: antoniovandre_elzf (R), matrix ([Q, R]))$

/* Verificar se uma matriz é nula. Argumento: "M" matriz. */

antoniovandre_matrixzero (M) := block ([n, m, i, j, s, o], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_matrixzero, ", timedate ())), n : length (M), m : length (transpose (M)), s : 0, for i : 1 thru n do for j : 1 thru m do s : s + M [i, j], if s = 0 then o : true else o : false, o)$

/* Divisão de polinômios em 1 variável, com saída formatada. Argumentos: "P" polinômio, "D" polinômio. */

antoniovandre_dp1v_format (P, D) := block ([M, di, dv, q, r, i, x, s, plus], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dp1v_format, ", timedate ())), s : "", M : antoniovandre_dp1v (P, D), di : length (P), dv : length (D), q: length (M [1, 1]), r : length (M [1, 2]), for i : 1 thru di do if not P [di - i + 1, 1] = 0 then (if (i = 1) or (P [di - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, P [di - i + 1, 1] * x^(di - i))), s : sconcat (s, " = ("), for i : 1 thru dv do if not D [dv - i + 1, 1] = 0 then (if (i = 1) or (D [dv - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, D [dv - i + 1, 1] * x^(dv - i))), s : sconcat (s, ")("), for i : 1 thru q do if not M [1, 1] [q - i + 1, 1] = 0 then (if (i = 1) or (M [1, 1] [q - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, M [1, 1] [q - i + 1, 1] * x^(q - i))), s : sconcat (s, ") + "), if antoniovandre_matrixzero (M [1, 2]) then s : sconcat (s, "0") else for i : 1 thru r do if not M [1, 2] [r - i + 1, 1] = 0 then (if (i = 1) or (M [1, 2] [r - i + 1, 1] < 0) then plus : "" else plus : "+", s : sconcat (s, plus, M [1, 2] [r - i + 1, 1] * x^(r - i))), s)$

/* Fatorial. Argumento: "n" número natural. */

antoniovandre_fatorial (n) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes and n = 0 then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_fatorial, ", timedate ())), if n > 0 then n * antoniovandre_fatorial (n - 1) else 1)$

/* Remover linha "i" e coluna "j" da matriz. Argumentos: "M" matriz, "i" número natural, "j" número natural. */

antoniovandre_rmlc (M, i, j) := block ([l, l2, k, k2, c, c2, Mo], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_rmlc, ", timedate ())), l : length (M), l2 : length (transpose (M)), Mo : zeromatrix (l - 1, l2 - 1), c : 0, for k : 1 thru l do if not k = i then (c : c + 1, c2 : 0, for k2 : 1 thru l2 do if not k2 = j then (c2 : c2 + 1, Mo [c, c2] : 1 * M [k, k2])), Mo)$

/* Determinante sem armazenamento de estatísticas. Função auxiliar de "antoniovandre_determinante". Argumento: "M" matriz quadrada. */

antoniovandre_det (M) := block ([l, i, d], l : length (M), d : 0, if l > 1 then for i : 1 thru l do d : d + M [i, 1] * (-1) ^ (i + 1) * antoniovandre_det (antoniovandre_rmlc (M, i, 1)) else d : 1 * M [1, 1], d)$

/* Determinante. Argumento: "M" matriz quadrada. */

antoniovandre_determinante (M) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat (", ", timedate ())), antoniovandre_det (M))$

/* Arranjos de "n" elementos tomados "p" a "p". Argumentos: "n" número natural, "p" número natural menor ou igual a "n". */

antoniovandre_arranjos (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_arranjos, ", timedate ())), antoniovandre_fatorial (n) / antoniovandre_fatorial (n - p))$

/* Arranjos com repetição de "n" elementos tomados "p" a "p". Argumentos: "n" número natural, "p" número natural menor ou igual a "n". */

antoniovandre_arranjos_repeticao (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_arranjos_repeticao, ", timedate ())), n ^ p)$

/* Combinações de "n" elementos tomados "p" a "p". Argumentos: "n" número natural, "p" número natural menor ou igual a "n". */

antoniovandre_combinacoes (n, p) := block ([], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_combinacoes, ", timedate ())), antoniovandre_arranjos (n, p) / antoniovandre_fatorial (p))$

/* Permutações com repetição de "n" elementos, em que um ou mais elementos são repetidos com os números de repetições que estão no vetor-linha "r". Argumentos: "n" número natural, "r" vetor-linha cuja soma dos elementos não ultrapasse "n". */

antoniovandre_permutacoes_repeticao (n, r) := block ([l, i, f], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_permutacoes_repeticao, ", timedate ())), l : length (transpose (r)), f : 1, for i : 1 thru l do f : f * antoniovandre_fatorial (r [1, i]), antoniovandre_fatorial (n) / f)$

/* Média aritmética dos elementos de um vetor. Argumento: "v" vetor-linha. */

antoniovandre_media_aritmetica (v) := block ([i, n, s : 0], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_media_aritmetica, ", timedate ())), n : length (transpose (v)), for i : 1 thru n do s : s + v [1, i], s / n)$

/* Média aritmética ponderada dos elementos de uma linha de uma matriz. Argumento: "m"  matriz de duas linhas, na primeira os valores, e, na segunda, os respectivos pesos. */

antoniovandre_media_aritmetica_ponderada (m) := block ([i, n, s : 0, sp : 0], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_media_aritmetica_ponderada, ", timedate ())), n : length (transpose (m)), for i : 1 thru n do (s : s + m [1, i] * m [2, i], sp : sp + m [2, i]), s / sp)$

/* Média geométrica dos elementos de um vetor. Argumento: "v" vetor-linha. */

antoniovandre_media_geometrica (v) := block ([i, n, p : 1], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_media_geometrica, ", timedate ())), n : length (transpose (v)), for i : 1 thru n do p : p * v [1, i], antoniovandre_nthroot (p, n))$

/* Média harmônica dos elementos de um vetor. Argumento: "v" vetor-linha. */

antoniovandre_media_harmonica (v) := block ([i, n, s : 0], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_media_harmonica, ", timedate ())), n : length (transpose (v)), for i : 1 thru n do s : s + 1 / v [1, i], n / s)$

/* Desvio absoluto médio dos elementos de um vetor. Argumento: "v" vetor-linha. */

antoniovandre_dam (v) := block ([ma, i, n, s : 0], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_dam, ", timedate ())), ma : antoniovandre_media_aritmetica (v), n : length (transpose (v)), for i : 1 thru n do s : s + abs (v [1, i] - ma), s / n)$

/* Variância dos elementos de um vetor. Argumento: "v" vetor-linha. */

antoniovandre_variancia (v) := block ([ma, i, n, s : 0], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_variancia, ", timedate ())), ma : antoniovandre_media_aritmetica (v), n : length (transpose (v)), for i : 1 thru n do s : s + (v [1, i] - ma)^2, s / n)$

/* Desvio padrão dos elementos de um vetor. Argumento: "v" vetor-linha. */

antoniovandre_desvio_padrao (v) := block ([ma, i, n, s : 0], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_desvio_padrao, ", timedate ())), sqrt (antoniovandre_variancia (v)))$

/* Matriz de frequências. Os dados de entrada são os elementos da matriz argumento, e os dados são separados em classes de mesma amplitude em um número passado como argumento. Argumentos: "M" matriz, "n" número natural. */

antoniovandre_matriz_frequencias (M, n) := block ([l, c, i, j, k, min : 99999, max : -99999, o], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_matriz_frequencias, ", timedate ())), l : length (M), c : length (transpose (M)), for i : 1 thru l do for j : 1 thru c do (if min > M [i, j] then min : M [i, j], if max < M [i, j] then max : M [i, j]), s : (max - min) / n, o : zeromatrix (n, 4), for i : 1 thru l do for j : 1 thru c do for k : 1 thru n do (o [k, 1] : min + (k - 1) * s, o [k, 2] : min + k * s, if (M [i, j] >= min + (k - 1) * s) and (((k < n) and (M [i, j] < min + k * s)) or ((k = n) and (M [i, j] <= min + k * s))) then o [k, 3] : o [k, 3] + 1), for i : 1 thru n do o [i, 4] : o [i, 3] / (l * c), o)$

/* Dados em rol, em uma matriz-linha. Os dados de entrada estão em uma matriz argumento. Argumentos: "M" matriz de números de ao menos 2 elementos, "r" um dos valores 0 ou outro número qualquer, para rol crescente ou decrescente, respecificamente. */

antoniovandre_rol (M, r) := block ([i, j, l, c, b, t, s, flag : 0, o], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_rol, ", timedate ())), l : length (M), c : length (transpose (M)), t : l * c, o : zeromatrix (1, t), if t = 1 then o [1, 1] : 1 * M [1, 1] else (for i : 1 thru t do (s : mod (i, c), if s = 0 then s : c, o [1, i] : 1 * M [ceiling (i / c), s]), for j : 1 while flag = 0 step 0 do (flag : 1, for i : 1 while mod (i, 2 * t) # 0 step 1 do (if r = 0 then (if o [1, mod (i, t - 1) + 1] > o [1, mod (i, t - 1) + 2] then (b : 1 * o [1, mod (i, t - 1) + 1], o [1, mod (i, t - 1) + 1] : 1 * o [1, mod (i, t - 1) + 2], o [1, mod (i, t - 1) + 2] : b, flag : 0)) else (if o [1, mod (i, t - 1) + 1] < o [1, mod (i, t - 1) + 2] then (b : 1 * o [1, mod (i, t - 1) + 1], o [1, mod (i, t - 1) + 1] : 1 * o [1, mod (i, t - 1) + 2], o [1, mod (i, t - 1) + 2] : b, flag : 0))))), o)$

/* Mediana de um conjunto de dados passados como uma matriz por argumento. Argumento: "M" matriz de números. */

antoniovandre_mediana (M) := block ([r, l, m], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_mediana, ", timedate ())), r : antoniovandre_rol (M, 0), l : length (transpose (r)), if mod (l, 2) = 0 then m : (r [1, l / 2] + r [1, l / 2 + 1]) / 2 else m : r [1, ceiling (l / 2)], m)$

/* Moda de um conjunto de dados numéricos passados como uma matriz argumento. Argumento : "M" matriz de números. */

antoniovandre_moda (M) := block ([i, j, k, l, c, t, b, b2, b3, b4, e, a : 1], if antoniovandre_armazenar_estatisticas_uso_funcoes then stringout (antoniovandre_arquivo_estatisticas_funcoes, sconcat ("antoniovandre_moda, ", timedate ())), l : length (M), c : length (transpose (M)), t : l * c, b : zeromatrix (t, 2), for i : 1 thru l do for j : 1 thru c do (flag : 0, for k : 1 thru t do (if M [i, j] = b [k, 1] then b [k, 2] : b [k, 2] + 1, if (b [k, 1] = 0) and (flag = 0) then (e : k, flag : 1)), if flag = 1 then (b [e, 1] : 1 * M [i, j], b [e, 2] : 1)), b2 : zeromatrix (t, 1), for i : 1 thru t do b2 [i, 1] : 1 * b [i, 2], b3 : antoniovandre_rol (b2, 1), flag : 0, for i : 2 while (flag = 0 and i < t) step 1 do (flag : 0, if b3 [1, i - 1] # b3 [1, i] then (e : i - 1, flag : 1)), if flag = 0 then e : t, b4 : zeromatrix (e, 2), for i : 1 thru t do if b3 [1, 1] = b [i, 2] then (b4 [a, 1] : 1 * b [i, 1], b4 [a, 2] : 1 * b [i, 2], a : a + 1), b4)$

/* Início funções e procedimentos em desenvolvimento.

Fim funções e procedimentos em desenvolvimento. */

/* Fim funções e procedimentos programados por Antonio Vandré Pedrosa Furtunato Gomes. */

